package org.symlabs.browser.editor;

import org.symlabs.browser.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Vector;
import javax.swing.Action;
import javax.swing.JPopupMenu;
import org.apache.log4j.Logger;
import org.symlabs.table.ArrayTableModel;
import org.symlabs.util.Utils;
import java.awt.*;
import java.awt.event.*;
import java.util.Vector;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.table.*;
import org.symlabs.actions.node.RefreshTree;
import org.symlabs.browser.attribute.AttributeManageDialog;
import org.symlabs.nodes.LDAPNode;
import org.symlabs.nodes.TreeRootNode;
import org.symlabs.util.Schema;

/**
 * <p>Titulo: TableEditor </p>
 * <p>Descripcion: Panel that manages and shows the attributes contained in the current node. </p>
 * <p>Copyright: Emilio Fernandez  2009</p>
 * @author Emilio J. Fernandez Rey
 * @version 1.0
 * @id $Id: EditorTable.java,v 1.10 2009-08-07 07:34:48 efernandez Exp $
 */
public class EditorTable extends EditorPanel {

    /**Attribute that stores the default value for this editor*/
    public static final String DEFAULT_EDITOR_TITLE = "Table";
    /**Attribute used to display the debug message*/
    private static Logger logger = Logger.getLogger(EditorTable.class);
    /**Attribute that contains the default column names for this table*/
    private final String[] defaultColumnNames = new String[]{"Attribute Type", "Value(s)"};
    /**Attribute that contains the default class types for this table*/
    private final Class[] defaultClassTypes = new Class[]{String.class, String.class};
    /**Attribute that contains the default value fos this table*/
    private final Object[] defaultValues = new Object[]{"", ""};
    /**Attribute that contains the default cell editable for this table*/
    private final Boolean[] defaultEditable = new Boolean[]{false, false};
    /**Attribute that contains the total number of Dns displayed in the table*/
    private final int totalDn = 0;
    /**Attribute that contains the popup displayed in the table, it is shown manage objectclasses and managea attributes. 
     * This attribute is used for single valued attributes*/
    private JPopupMenu popupTable;
    /**Attribute that contains the popup displayed in the table. It is shown manage objectclasses, manage attributes, and adds attributes.
     * This attribute is used for multivalued attributes*/
    private JPopupMenu popupTableWithValues;
    /**Attribute that contains the tableHeader of the table. It cotains the table column names*/
    private JTableHeader tableHeader;

    /** Constructor: Creates new form TableEditor 
     * 
     */
    public EditorTable() {
        initComponents();
        initProperties();
        this.editorType = EditorTable.DEFAULT_EDITOR_TITLE;
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        table = new javax.swing.JTable();

        getEditorContainerDelegate().setLayout(new java.awt.GridBagLayout());

        table.setAutoCreateRowSorter(true);
        table.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridheight = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        getEditorContainerDelegate().add(table, gridBagConstraints);
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTable table;
    // End of variables declaration//GEN-END:variables
    /**Method that sets this editor to edit. It sets the values colum to editable
     * 
     * @param editable boolean. This parameter indicates if the editor is setted as editable
     */
    @Override
    public void setEditableEditor(boolean editable) {
        super.setEditableEditor(editable);
        if (this.table != null && this.table.getModel() != null) {
            ArrayTableModel model = (ArrayTableModel) this.table.getModel();
            ArrayList<Object[]> data = model.getData();
            int rowCount = model.getRowCount();
            rowCount--;//We have to substract the last row, this is the empty row
            for (int i = 0; i < rowCount; i++) {
                if (i < this.totalDn || i >= (this.totalDn + this.getTotalObjectClassesNumber(data))) {
                    model.setPosEditable(i, 1, editable);
                }
            }
        }
    }

    /**Method that returns the editor type. This field contains the title of the editor displayed
     * 
     * @return String. This is the title of the editor displayed
     */
    @Override
    public String getEditorType() {
        return DEFAULT_EDITOR_TITLE;
    }

    /**Method that initializes the components
     * 
     */
    @Override
    public void initProperties() {
        GridBagConstraints gridBagConstraints;
        if (this.table != null && this.containerPanel != null) {
            //We initialize the values of new attributes
            this.newAttributes = Utils.getCopyOfHashMap(this.attributes);

            this.initPopup();

            // <editor-fold defaultstate="collapsed" desc=" Set the table header and disable the reorder ">
            //createTableHeader
            this.tableHeader = this.table.getTableHeader();

            gridBagConstraints = new java.awt.GridBagConstraints();
            gridBagConstraints.gridx = 0;
            gridBagConstraints.gridy = 0;
            gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
            gridBagConstraints.weightx = 1.0;
            gridBagConstraints.weighty = 0;
            // <editor-fold defaultstate="collapsed" desc=" Disable reorder columns and column values ">
            //We do not want to allow reorder the columns or the column values
            this.tableHeader.setReorderingAllowed(false);
            this.table.setAutoCreateRowSorter(false);
            this.table.setRowSorter(null);
            // </editor-fold>
            getEditorContainerDelegate().add(this.tableHeader, gridBagConstraints);

            // </editor-fold>

            //We load the table values
            this.initTableValues(this.attributes);
        }
    }

    /**Method that initializes the values of the table editor. The hash given as parameter will be the values to set.
     * 
     * @param hash HashMap <String,String[]>. This hash contains the values to set in this table
     */
    private void initTableValues(HashMap<String, String[]> hash[]) {
        if (hash != null) {
            //Creates the table model
            ArrayList<Object[]> data = this.getDataValuesFromAttributes(hash);
            ArrayList<Boolean[]> editable = new ArrayList<Boolean[]>();
            for (int i = 0; i < data.size(); i++) {
                editable.add(new Boolean[]{false, false});
            }
            //(ArrayList<Object[]> data, String [] colNames, ArrayList<Boolean[]> editable,Class[]classTypes,Object[] defaultValues,Boolean[] defaultEditable)
            ArrayTableModel model = new ArrayTableModel(data, this.defaultColumnNames, editable, this.defaultClassTypes, this.defaultValues, this.defaultEditable);

            //Sets the model
            this.table.setModel(model);
            this.tableHeader = this.table.getTableHeader();

        }
    }

    /**Method that saves this changes in the ldap server
     * 
     */
    @Override
    public boolean saveChanges() {
        ArrayTableModel model = (ArrayTableModel) this.table.getModel();
        this.newAttributes = this.getHashMapValuesFromData(model.getData());

        boolean saved = super.saveChanges();

        //We update the values of the table...
        Utils.getAction(RefreshTree.HashKey).getAction().actionPerformed(null);

        //We set the current the default editor as selected
        Utils.getMainWindow().getCurrentBrowserPanel().setCurrentEditor(EditorTable.DEFAULT_EDITOR_TITLE);

        return saved;
    }

    /**Method that returns the data needed for the arrayTableModel. This data are created by the hashMap given as argument.
     * 
     * @param hashMap HashMap String, String[] . This HashMap contains the data to load in the table
     * @return ArrayList Object[]. This ArraList contains the data needed by the ArrayTableModel.
     */
    private ArrayList<Object[]> getDataValuesFromAttributes(HashMap<String, String[]> hashMap[]) {
        ArrayList<Object[]> data = new ArrayList<Object[]>();
        for (int i = 0; i < hashMap.length; i++) {
            Iterator it = hashMap[i].entrySet().iterator();
            while (it.hasNext()) {
                //Add the attribute 
                Map.Entry entry = (Map.Entry) it.next();
                String attributeName = (String) entry.getKey();
                if (attributeName.equalsIgnoreCase("objectclass")) {
                    attributeName = Utils.getAttributeInBold(attributeName);
                }
                String attrValues[] = (String[]) entry.getValue();
                for (int j = 0; j < attrValues.length; j++) {
                    data.add(new Object[]{attributeName, attrValues[j]});
                }
            }
        }
        return data;
    }

    /**Method that returns a hashmap with the attributes given by the argument ArrayList
     * We need to know the order of the attributes displayed: dn, objectaclasses, other attributes.
     * 
     * @param data ArrayList. This array contains the attributes displayed in the table.
     * @return HashMap. This hashmap contains the attributes contained in the arraylist.
     */
    private HashMap<String, String[]>[] getHashMapValuesFromData(ArrayList<Object[]> data) {
        int totDn = this.newAttributes[LDAPNode.INDEX_DN].size();//It must be 0
        int totObj = this.getTotalObjectClassesNumber(data);

        HashMap<String, String[]> hash[] = new HashMap[3];
        hash[LDAPNode.INDEX_DN] = this.getHashMapAttributeFromData(data, totDn - 1, totDn);//init, this.totalDn);
        hash[LDAPNode.INDEX_OBJECTCLASSES] = this.getHashMapAttributeFromData(data, totDn, totDn + totObj - 1);//this.totalDn, this.totalDn + this.totalObjectclasses - 1);
        hash[LDAPNode.INDEX_ATTRIBUTES] = this.getHashMapAttributeFromData(data, totDn + totObj - 1, data.size());//this.totalDn + this.totalObjectclasses - 1, data.size());

        logger.trace("We print the hash!!!!");
        Utils.printHash(hash);
        return hash;
    }

    private int getTotalObjectClassesNumber(ArrayList<Object[]> data) {
        int totalObjectClasses = 0;
        for (int i = 0; i < data.size(); i++) {
            Object[] row = data.get(i);
            String attrName = (String) row[0];
            String attrValue = (String) row[1];
            attrName = Utils.getAttributeWithoutBold(attrName);
            if (attrName.equalsIgnoreCase(Schema.OBJECTCLASS_KEY)) {
                totalObjectClasses++;
            }
            logger.trace("data.get(" + i + "):" + attrName+", value:"+attrValue);
        }
        logger.trace("The total number of objectclasses is: " + totalObjectClasses);
        return totalObjectClasses;
    }

    /**Method that returns a hashmap with the attributes given by the indexes
     * 
     * @param data ArrayList. This array contains the data of the table
     * @param indexInit int. This is the initial index to search
     * @param indexEnd int. This is the en index to search
     * @return HashMap String,String[]. This is the hash that contains the attributes found between the indexe: init and end
     */
    private HashMap<String, String[]> getHashMapAttributeFromData(ArrayList<Object[]> data, int indexInit, int indexEnd) {
        logger.trace("data.size:" + data.size() + ",indexInit:" + indexInit + ",indexEnd:" + indexEnd);
        HashMap<String, String[]> hash = new HashMap<String, String[]>();
        if (indexInit < indexEnd) {
            Object[] object = data.get(indexInit);
            String attrName = (String) object[0];
            String attrValue = (String) object[1];
            String attrValues[] = null;
            Vector vValues = new Vector();
            while (indexInit < indexEnd && data.size() > indexInit) {
                logger.trace("indexInit:" + indexInit + ",indexEnd:" + indexEnd);
                object = data.get(indexInit);
                if (object[0].equals(attrName)) {
                    vValues.addElement(object[1]);
                    attrName = (String) object[0];
                } else {
                    //We save in the hashmap the values stored
                    attrValues = new String[vValues.size()];
                    for (int j = 0; j < vValues.size(); j++) {
                        attrValues[j] = (String) vValues.elementAt(j);
                    }
                    attrName = Utils.getAttributeWithoutBold(attrName);
                    hash.put(attrName, attrValues);
                    attrName = (String) object[0];
                    attrValue = (String) object[1];
                    vValues.removeAllElements();
                    vValues.addElement(attrValue);
                }
                indexInit++;
            }
            if (!vValues.isEmpty()) {
                attrValues = new String[vValues.size()];
                for (int j = 0; j < vValues.size(); j++) {
                    attrValues[j] = (String) vValues.elementAt(j);
                }
                attrName = Utils.getAttributeWithoutBold(attrName);
                hash.put(attrName, attrValues);
            }
        }
        return hash;
    }

    /**Method that initializes the popup for the edition table
     * 
     */
    private void initPopup() {
        //Create the popup menu.
        popupTable = new JPopupMenu();
        this.popupTableWithValues = new JPopupMenu();
        Action action = new AbstractAction("Manage Objectclasses") {

            public void actionPerformed(ActionEvent e) {
                int selRow = table.getSelectedRow();
                manageObjectclass(selRow);
            }
        };
        popupTable.add(action);
        this.popupTableWithValues.add(action);

        action = new AbstractAction("Manage Attributes") {

            public void actionPerformed(ActionEvent e) {
                int selRow = table.getSelectedRow();
                manageAttribute(selRow);
            }
        };
        popupTable.add(action);
        this.popupTableWithValues.add(action);

        action = new AbstractAction("Add Value") {

            public void actionPerformed(ActionEvent e) {
                int selRow = table.getSelectedRow();
                ArrayTableModel model = (ArrayTableModel) table.getModel();
                ArrayList<Object[]> data = model.getData();
                int previousRows = totalDn + getTotalObjectClassesNumber(data);
                if (selRow >= previousRows) {
                    // <editor-fold defaultstate="collapsed" desc=" We get the attribute name of the selected row">
                    Object[] row = model.getRow(selRow);
                    String attributeName = "";
                    if (row.length == defaultColumnNames.length) {
                        attributeName = (String) row[0];
                    }
                    // </editor-fold>
                    addAttributeValues(selRow, attributeName);
                }
            }
        };
        this.popupTableWithValues.add(action);

        action = new AbstractAction("Remove Value") {

            public void actionPerformed(ActionEvent e) {
                int selRow = table.getSelectedRow();
                ArrayTableModel model = (ArrayTableModel) table.getModel();
                ArrayList<Object[]> data = model.getData();
                int previousRows = totalDn + getTotalObjectClassesNumber(data);
                if (selRow >= previousRows) {
                    // <editor-fold defaultstate="collapsed" desc=" We get the attribute name of the selected row">
                    Object[] row = model.getRow(selRow);
                    String attributeName = "";
                    if (row.length == defaultColumnNames.length) {
                        attributeName = (String) row[0];
                    }
                    // </editor-fold>
                    removeAttributeValues(selRow, attributeName);
                }
            }
        };
        this.popupTableWithValues.add(action);

        MouseListener ml = new MouseAdapter() {

            @Override
            public void mousePressed(MouseEvent e) {
                if (editorMode.equalsIgnoreCase(EditorPanel.EDITOR_MODE_EDIT)) {
                    logger.trace("We are going to show the popup of editor table");
                    int selRow = table.getSelectedRow();
                    int totalRows = table.getRowCount() - 1; //Because the last row can not be selected
                    ArrayTableModel model = (ArrayTableModel) table.getModel();
                    ArrayList<Object[]> data = model.getData();
                    if (selRow >= 0 && selRow < totalRows) {
                        int previousRows = totalDn + getTotalObjectClassesNumber(data);//This is the number of rows displayed that contains the number of rows of the DN and the Objectclasses
                        // <editor-fold defaultstate="collapsed" desc=" We need to know if the attribute selected is single or multi valued ">
                        //We need to know if this attribute is single valued
                        Object[] row = model.getRow(selRow);
                        String attributeName = "";
                        if (row.length == defaultColumnNames.length) {
                            attributeName = (String) row[0];
                        }
                        boolean singleValued = true;
                        if (e.isPopupTrigger() && selRow != -1 && selRow >= previousRows) {
                            singleValued = ((TreeRootNode) ldapNode.getRoot()).getLdapServer().getLdapSchema().isSingleValued(Utils.getAttributeWithoutBold(attributeName));
                        }
                        // </editor-fold>
                        if (e.isPopupTrigger() && selRow != -1 && selRow >= previousRows && !singleValued) {
                            popupTableWithValues.show(e.getComponent(), e.getX(), e.getY());
                        } else if (e.isPopupTrigger() && selRow != -1) {
                            popupTable.show(e.getComponent(), e.getX(), e.getY());
                        }
                    }
                }
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                mousePressed(e);
            }
        };
        this.table.addMouseListener(ml);
    }

    /**Method that returns a hashmap with the objectclasses found in the table
     * 
     * @return HashMap String,String[]. This hashmap contains the objectclasses found in the table
     */
    private HashMap<String, String[]> getTableObjectclasses() {
        ArrayTableModel model = (ArrayTableModel) this.table.getModel();
        ArrayList<Object[]> data = model.getData();
        int totObj = this.getTotalObjectClassesNumber(data);
        return this.getHashMapAttributeFromData(data, 1, totObj+1);//this.totalDn, this.totalDn + this.totalObjectclasses);
    }

    /**Method that returns a hashmap with the attributes found in the table
     * 
     * @return HashMap String, Stirng[]. This hashmap contains the attributes found in the table
     */
    private HashMap<String, String[]> getTableAttributes() {
        ArrayTableModel model = (ArrayTableModel) this.table.getModel();
        ArrayList<Object[]> data = model.getData();
        int totObj = this.getTotalObjectClassesNumber(data);
        return this.getHashMapAttributeFromData(data, totObj, data.size());//this.totalDn + this.totalObjectclasses, data.size());
    }

    /**Method that shows the window to manage the objectclasses
     * 
     * @param selRow int. This is the row where we want to add this objectclass
     */
    private void manageObjectclass(int selRow) {
        //Get the hashmap of table objectclasses
        HashMap<String, String[]> hashAttributes = this.getTableAttributes();
        Iterator it = hashAttributes.entrySet().iterator();
        Vector vObjectclasses = new Vector();
        vObjectclasses = ((TreeRootNode) this.ldapNode.getRoot()).getLdapServer().getLdapSchema().getAllObjectclasses();

        logger.trace("It is created the manage dialog, values of new hash:");
        Utils.printHash(newAttributes);

        AttributeManageDialog addAttribute =
                new AttributeManageDialog(
                Utils.getVectorAttributesFromHashMap(this.newAttributes, LDAPNode.INDEX_OBJECTCLASSES),
                vObjectclasses,
                this.newAttributes);
        addAttribute.setSize(500, 400);
        addAttribute.setLocationRelativeTo(Utils.getMainWindow());
        addAttribute.setVisible(true);

        Vector vSelectingAttrs = addAttribute.getAttributesSelected();
        Vector vExistingAttrs = addAttribute.getExistingAttributes();
        Vector vAttrRemoved = new Vector();
        Vector vAttrAdded = new Vector();

        //We search the attributes added
        for (int i = 0; i < vSelectingAttrs.size(); i++) {
            if (!vExistingAttrs.contains(vSelectingAttrs.elementAt(i))) {
                vAttrAdded.addElement(vSelectingAttrs.elementAt(i));
            }
        }

        //We search the attributes removed
        for (int i = 0; i < vExistingAttrs.size(); i++) {
            if (!vSelectingAttrs.contains(vExistingAttrs.elementAt(i))) {
                vAttrRemoved.addElement(vExistingAttrs.elementAt(i));
            }
        }

        //We set the new values in the attribute newAttributes
        this.setNewAttributesByManageObjectclasses(vAttrAdded, vAttrRemoved);

        //We have to update this panel
        this.initTableValues(this.newAttributes);

        //We set the edit mode to true
        this.setEditableEditor(true);


//        this.calculateNumberOfDnAndObjectclasses();

        logger.trace("It is getted the values of the manage dialog, values of new hash:");
        Utils.printHash(newAttributes);

    }

    /**Method that shows the window to manage an attribute
     * 
     * @param selRow int. This is the row where we want to add this attribute
     */
    private void manageAttribute(int selRow) {
        //Get the hashmap of table objectclasses
        HashMap<String, String[]> hashObjectclass = this.getTableObjectclasses();
        Iterator it = hashObjectclass.entrySet().iterator();
        Vector vRequiredAttributes = new Vector();
        Vector vOptionalAttributes = new Vector();
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            String objectclassName = (String) entry.getKey();
            String[] objectclassValues = (String[]) entry.getValue();
            for (int i = 0; i < objectclassValues.length; i++) {
                logger.trace("manageAttribute, objectclass Value:"+objectclassValues[i]);
                vRequiredAttributes = ((TreeRootNode) this.ldapNode.getRoot()).getLdapServer().getLdapSchema().getRequiredAttributes(objectclassValues[i], vRequiredAttributes);
                vOptionalAttributes = ((TreeRootNode) this.ldapNode.getRoot()).getLdapServer().getLdapSchema().getOptionalAttributes(objectclassValues[i], vOptionalAttributes);
            }
        }

        AttributeManageDialog addAttribute =
                new AttributeManageDialog(
                Utils.getVectorAttributesFromHashMap(this.newAttributes, LDAPNode.INDEX_ATTRIBUTES),
                vRequiredAttributes,
                vOptionalAttributes,
                this.newAttributes);

        addAttribute.setSize(500, 400);
        addAttribute.setLocationRelativeTo(Utils.getMainWindow());
        addAttribute.setVisible(true);

        //We get the attributes selected
        Vector vSelectingAttrs = addAttribute.getAttributesSelected();
        //We get the initial attributes
        Vector vExistingAttrs = addAttribute.getExistingAttributes();
        Vector vAttrRemoved = new Vector();
        Vector vAttrAdded = new Vector();

        logger.debug("Selected " + vSelectingAttrs.size() + " atributes.");
        //We search the attributes added
        for (int i = 0; i < vSelectingAttrs.size(); i++) {
            if (!vExistingAttrs.contains(vSelectingAttrs.elementAt(i))) {
                vAttrAdded.addElement(vSelectingAttrs.elementAt(i));
            }
        }

        logger.debug("Existing " + vExistingAttrs.size() + " atributes.");
        //We search the attributes removed
        for (int i = 0; i < vExistingAttrs.size(); i++) {
            if (!vSelectingAttrs.contains(vExistingAttrs.elementAt(i))) {
                vAttrRemoved.addElement(vExistingAttrs.elementAt(i));
            }
        }

        //We set the new attributes
        this.setNewAttributesByManageAttributes(vAttrAdded, vAttrRemoved);

        //We have to update this panel
        this.initTableValues(this.newAttributes);

        //We set the edit mode to true
        this.setEditableEditor(true);

//        this.calculateNumberOfDnAndObjectclasses();
    //        ((ArrayTableModel) table.getModel()).insertRowAfter(selRow);
    }

    private void setNewAttributesByManageObjectclasses(Vector<String> attributesAdded, Vector<String> attributesRemoved) {
        //We get the values loaded in the table displayed
        if (this.newAttributes == null) {
            ArrayTableModel model = (ArrayTableModel) this.table.getModel();
            this.newAttributes = this.getHashMapValuesFromData(model.getData());
        }

        logger.trace("We are in objectclasses");
        // <editor-fold defaultstate="collapsed" desc=" We get the objectClass name attribute ">
        //We get the objectClass name
        Iterator it = this.newAttributes[LDAPNode.INDEX_OBJECTCLASSES].entrySet().iterator();
        String objectclass = null;
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            objectclass = (String) entry.getKey();
        }
        // </editor-fold>   

        //We get the rdn attribute
        it = this.newAttributes[LDAPNode.INDEX_DN].entrySet().iterator();
        String rdnAttribute = "";
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            rdnAttribute = (String) entry.getKey();
        }

        if (attributesRemoved != null) {
            logger.trace("We are in objectclasses removed");
            //First we remove the attributes
            for (int i = 0; i < attributesRemoved.size(); i++) {
                // <editor-fold defaultstate="collapsed" desc=" We get the values for this objectclass ">
                String[] attrValues = this.newAttributes[LDAPNode.INDEX_OBJECTCLASSES].get(objectclass);
                String newAttrValues[] = new String[attrValues.length - 1];
                int cont = 0;
                for (int j = 0; j < attrValues.length; j++) {
                    if (!attrValues[j].equals(attributesRemoved.elementAt(i))) {
                        newAttrValues[cont] = attrValues[j];
                        cont++;
                    }
                }
                // </editor-fold>

                // <editor-fold defaultstate="collapsed" desc=" We set the new values for this objectclass ">
                //We set the new values for this objectclass
                for (int j = 0; j < newAttrValues.length; j++) {
                    logger.trace("establecemos para la objectclass los values:" + newAttrValues[j]);
                }
                this.newAttributes[LDAPNode.INDEX_OBJECTCLASSES].put(objectclass, newAttrValues);
            // </editor-fold>
            }
        } //End attributes removed

        if (attributesAdded != null) {
            logger.trace("We are in objectclasses added");
            // <editor-fold defaultstate="collapsed" desc=" We add the new objectclasses values ">
            //We add the new attributes  
            for (int i = 0; i < attributesAdded.size(); i++) {

                // <editor-fold defaultstate="collapsed" desc=" We calculate and create the new values for the objectclass ">
                //We have to add this value from the String[] values
                String attrValues[] = this.newAttributes[LDAPNode.INDEX_OBJECTCLASSES].get(objectclass);
                String newAttrValues[] = new String[attrValues.length + 1];
                for (int j = 0; j < attrValues.length; j++) {
                    newAttrValues[j] = attrValues[j];
                }
                newAttrValues[newAttrValues.length - 1] = attributesAdded.elementAt(i);
                // </editor-fold>

                //We set the new values for this objectclass
                this.newAttributes[LDAPNode.INDEX_OBJECTCLASSES].remove(objectclass);
                this.newAttributes[LDAPNode.INDEX_OBJECTCLASSES].put(objectclass, newAttrValues);

            }//End for attributesAdded
        // </editor-fold>
        }//End attributes added


        //We get attributes
        Vector<String> existingAttrs = new Vector<String>();
        Iterator iterator = this.newAttributes[LDAPNode.INDEX_ATTRIBUTES].entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry entry = (Map.Entry) iterator.next();
            String attrName = (String) entry.getKey();
            logger.trace("Adding the existing attribute:" + attrName);
            existingAttrs.addElement(attrName);
        }

        //We get the objectclasses
        String[] allObjs = this.newAttributes[LDAPNode.INDEX_OBJECTCLASSES].get(objectclass);
        Vector<String> allObjectClasses = new Vector<String>();
        for (int i = 0; i < allObjs.length; i++) {
            logger.trace("Adding objectClasses: " + allObjs[i]);
            allObjectClasses.addElement(allObjs[i]);
        }

        allObjectClasses = Schema.removeAttributeObjectClass(allObjectClasses);

        Schema schema = ((TreeRootNode) this.ldapNode.getRoot()).getLdapServer().getLdapSchema();

        //We get the required attributes of all objectclasses
        Vector<String> requiredAttrs = schema.getRequiredAttributes(allObjectClasses);

        //We get the optional attributes of all objectclasses
        Vector<String> optionalAttrs = schema.getOptionalAttributes(allObjectClasses);

        //First we remove the attributes that we do not need
        Vector<String> totalAttrs = new Vector<String>();
        if (requiredAttrs != null) {
            this.printVector(requiredAttrs);
            totalAttrs = Utils.getVectorAddingValues(totalAttrs, requiredAttrs);
        }

        //We remove the attribute objectclass
        totalAttrs = Schema.removeAttributeObjectClass(totalAttrs);

        if (optionalAttrs != null) {
            totalAttrs = Utils.getVectorAddingValues(totalAttrs, optionalAttrs);
        }

        //We remove from total attributes that attributes that was not found in our list of attributes
        Vector<String> attributesToRemove = new Vector<String>();
        attributesToRemove = Utils.getVectorRemovingValues(existingAttrs, totalAttrs);

        if (attributesToRemove != null && attributesToRemove.size() > 0) {
            this.setNewAttributesByManageAttributes(null, attributesToRemove);
        }

        //We test if all required attrs are in the existings attrs list
        Vector<String> attributesToAdd = new Vector<String>();
        for (int i = 0; i < requiredAttrs.size(); i++) {
            if (!existingAttrs.contains(requiredAttrs.elementAt(i))) {
                attributesToAdd.addElement(requiredAttrs.elementAt(i));
            }
        }

        if (attributesToAdd != null && attributesToAdd.size() > 0) {
            //We have to remove the objectclass attribute
            Schema.removeAttributeObjectClass(attributesToAdd);

            //We have to remove the rdn attribute of this class
            attributesToAdd.remove(rdnAttribute);

            this.setNewAttributesByManageAttributes(attributesToAdd, null);
        }

    }

    private void printVector(Vector<String> vectorToPrint) {
        for (int i = 0; i < vectorToPrint.size(); i++) {
            logger.trace("element[" + i + "]:" + vectorToPrint.elementAt(i));
        }
    }

    private void setNewAttributesByManageAttributes(Vector<String> attributesAdded, Vector<String> attributesRemoved) {
        logger.trace("We are in attributes");
        if (attributesRemoved != null) {
            logger.trace("We are in removed attributes");
            // <editor-fold defaultstate="collapsed" desc=" We remove the attributes ">
            //First we remove the attributes
            for (int i = 0; i < attributesRemoved.size(); i++) {
                if (newAttributes == null || this.newAttributes[LDAPNode.INDEX_ATTRIBUTES] == null) {
                    logger.trace("this.newAttributes[LDAPNode.INDEX_ATTRIBUTES]==null");
                } else if (this.newAttributes[LDAPNode.INDEX_ATTRIBUTES].containsKey(attributesRemoved.elementAt(i))) {
                    this.newAttributes[LDAPNode.INDEX_ATTRIBUTES].remove(attributesRemoved.elementAt(i));
                }
            }
        // </editor-fold>
        }

        if (attributesAdded != null) {
            logger.trace("We are in added attributes");
            // <editor-fold defaultstate="collapsed" desc=" We add the new attributes ">
            //We add the new attributes
            for (int i = 0; i < attributesAdded.size(); i++) {
                logger.trace("AttributesAdded.element(" + i + ":" + attributesAdded.elementAt(i));
                if (this.newAttributes == null) {
                    logger.trace("this.newAttributes == null");
                }
                if (this.newAttributes[LDAPNode.INDEX_ATTRIBUTES] == null) {
                    logger.trace("this.newAttributes[LDAPNode.INDEX_ATTRIBUTES] == null");
                }
                if (!this.newAttributes[LDAPNode.INDEX_ATTRIBUTES].containsKey(attributesAdded.elementAt(i))) {
                    this.newAttributes[LDAPNode.INDEX_ATTRIBUTES].put(attributesAdded.elementAt(i), new String[]{""});
                }
            }
        // </editor-fold>
        }
    }

    /**Method that adds a new row to the table with the attributeName given as argument
     * 
     * @param selRow int. This is the row selected
     * @param attributeName String. This is the attribute name where we want to add a new value
     */
    private void addAttributeValues(int selRow, String attributeName) {
        ArrayTableModel model = (ArrayTableModel) this.table.getModel();
        model.insertRowAfter(selRow);
        Object[] values = new Object[]{attributeName, ""};
        model.setRow(values, selRow + 1);
        this.setEditableEditor(true);

        if (this.newAttributes == null) {
            ArrayTableModel model2 = (ArrayTableModel) this.table.getModel();
            this.newAttributes = this.getHashMapValuesFromData(model2.getData());
        }
//        this.calculateNumberOfDnAndObjectclasses();
    }

    /**Method that removes a new row to the table with the attributeName given as argument
     * 
     * @param selRow int. This is the row selected
     * @param attributeName String. This is the attribute name where we want to remove a value
     */
    private void removeAttributeValues(int selRow, String attributeName) {
        ArrayTableModel model = (ArrayTableModel) this.table.getModel();
        model.deleteRow(selRow);
        this.setEditableEditor(true);
        this.validate();
        this.repaint();

        if (this.newAttributes == null) {
            ArrayTableModel model2 = (ArrayTableModel) this.table.getModel();
            this.newAttributes = this.getHashMapValuesFromData(model2.getData());
        }
//        this.calculateNumberOfDnAndObjectclasses();
    }
}
