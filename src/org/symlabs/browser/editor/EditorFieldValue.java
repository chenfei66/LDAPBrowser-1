package org.symlabs.browser.editor;

import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Vector;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JButton;
import javax.swing.JTextField;
import org.apache.log4j.Logger;
import org.symlabs.nodes.LDAPNode;
import org.symlabs.nodes.TreeRootNode;
import org.symlabs.util.Schema;
import org.symlabs.util.Utils;

/**
 * <p>Titulo: FieldValueEditor </p>
 * <p>Descripcion: Panel that manages and shows the attributes contained in the current node. 
 * The editor shows this information in format: Attribute-Value</p>
 * <p>Copyright: Emilio Fernandez  2009</p>
 * @author Emilio J. Fernandez Rey
 * @version 1.0
 * @id $Id: EditorFieldValue.java,v 1.12 2009-08-06 11:53:33 efernandez Exp $
 */
public class EditorFieldValue extends EditorPanel {

    /**Attribute that stores the default value for this editor*/
    public static final String DEFAULT_EDITOR_TITLE = "Field-Value";
    /**Attribute used to display the debug message*/
    private static Logger logger = Logger.getLogger(EditorFieldValue.class);
    /**Attribute that contains the textfield displayed in the container panel.
     * These are the attributes of the current node
     * Each element of this array will contain an array object with 4 elements: Label-with the attribute name, JTextfield with the attribute value. Add value button, Remove value button
     * The element 0 of this array will contain the DN, 
     * The element 1 will contain the objectclasses. 
     * The element 2 will contain other attributes.*/
    public Vector vTextField[];
    /**Attribute that contains the default value for a new attribute added*/
    private static final String DEFAULT_ATTRIBUTE_VALUE = "";
    /**Attribute that contains the value shown of the remove value button*/
    private static final String REMOVE_VALUE_BUTTON_IMAGEICON_PATH = Utils.ICON_VALUE_REMOVE; //We can change this attribute for an icon.
    /**Attribute that contains the value shown of theadd value button*/
    private static final String ADD_VALUE_BUTTON_IMAGEICON_PATH = Utils.ICON_VALUE_NEW; //We can change this attribute for an icon.
    /**Attribute that contains the string shown on the tool tip text remove value button*/
    private static final String REMOVE_VALUE_BUTTON_TOOLTIPTEXT = "It removes the row of the selected value.";
    /**Attribute that contains the string shown on the tool tip text remove value button*/
    private static final String ADD_VALUE_BUTTON_TOOLTIPTEXT = "Adds new row to add a new value.";
    /**Attribute used to get the attribute name*/
    private static final String ATTRIBUTE_NAME_KEY = "AttributeName";
    /**Attribute used to get the attribute value*/
    private static final String ATTRIBUTE_VALUE_KEY = "AttributeValue";
    /**Attribute used to indicates if we are removing a value or not*/
    private String editorValueMode;
    /**Attribute used to indicates that we are removing a value of an attribute*/
    private static final String MODE_REMOVING_VALUE = "Removing a Value";
    /**Attribute used to indeicate that we are adding a value to an attribute*/
    private static final String MODE_ADDING_VALUE = "Adding a Value";
    /**Attribute used to indicate that we are not removing and adding a value*/
    private static final String MODE_EDITING = "Editing";

    /**Constructor: Creates a new instance of FieldValueEditor
     * 
     */
    public EditorFieldValue() {
        logger.trace("EditorFieldValue 1");
        this.initComponents();
        logger.trace("EditorFieldValue 2");
        this.initProperties();
        this.editorType = EditorFieldValue.DEFAULT_EDITOR_TITLE;
        this.editorValueMode = MODE_EDITING;
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        getEditorContainerDelegate().setLayout(new java.awt.GridBagLayout());
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    /**Initializes the components of this panel.
     * 
     */
    @Override
    public void initProperties() {
        this.setAttributesHashMap(this.attributes);
    }

    /**Method that sets the hash given as argument as the attributes used for this hashmap
     * 
     * @param attributes HashMap <String,String[]> []. This hash contains the attributes that we want to display in this editor
     */
    public void setAttributesHashMap(HashMap<String, String[]> attributes[]) {
        GridBagConstraints gridBagConstraints;
        JLabel attrLabel;
        JTextField valueField;
        JButton removeButton = null;
        JButton addButton = null;

        //First of all we remove all components
        this.containerPanel.removeAll();

        //We set the layout to the containter panel. This is the container that it is going to display the attributes.
        this.containerPanel.setLayout(new GridBagLayout());

        //We creates the vector that it is going to contain the textfield
        this.vTextField = new Vector[3];
        int row = 0;

        if (attributes != null) {
            for (int i = 0; i < attributes.length; i++) {
                if (attributes[i] != null) {
                    Iterator it = attributes[i].entrySet().iterator();
                    //We set the attributes and add it to the panel
                    while (it.hasNext()) {
                        //Add the attribute 
                        Map.Entry entry = (Map.Entry) it.next();
                        String attributeName = (String) entry.getKey();
                        //We set the attributeName: objectClass in bold
                        if (i == LDAPNode.INDEX_OBJECTCLASSES) {
                            attributeName = Utils.getAttributeInBold(attributeName);
                        }
                        attrLabel = new JLabel(attributeName);
                        //If it is an attribute then we add the mouse listener
                        if (i == LDAPNode.INDEX_ATTRIBUTES) {
//                            attrLabel.addMouseListener(this.mouseListener);
                        }
                        // <editor-fold defaultstate="collapsed" desc=" Adds new attribute ">
                        gridBagConstraints = new java.awt.GridBagConstraints();
                        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
                        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
                        gridBagConstraints.weightx = 1.0;
                        gridBagConstraints.insets = new java.awt.Insets(0, 2, 0, 2);
                        gridBagConstraints.gridx = 0;
                        gridBagConstraints.gridy = row;
                        this.containerPanel.add(attrLabel, gridBagConstraints);
                        // </editor-fold>

                        String[] attrValues = (String[]) entry.getValue();

                        //Add the values for this attribute
                        for (int j = 0; j < attrValues.length; j++) {
                            if (i == LDAPNode.INDEX_ATTRIBUTES) {
                                valueField = new JTextField(attrValues[j]);

                                // <editor-fold defaultstate="collapsed" desc=" Adds value ">
                                gridBagConstraints = new java.awt.GridBagConstraints();
                                gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
                                gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
                                gridBagConstraints.weightx = 1.0;
                                gridBagConstraints.insets = new java.awt.Insets(0, 2, 0, 2);
                                gridBagConstraints.gridx = 1;
                                gridBagConstraints.gridy = row;
                                this.containerPanel.add(valueField, gridBagConstraints);
                                // </editor-fold>

                                // <editor-fold defaultstate="collapsed" desc=" We create the add value button an sets its properties ">
                                addButton = new JButton(Utils.createImageIcon(EditorFieldValue.ADD_VALUE_BUTTON_IMAGEICON_PATH));
                                addButton.putClientProperty(EditorFieldValue.ATTRIBUTE_NAME_KEY, attrLabel.getText());
                                addButton.putClientProperty(EditorFieldValue.ATTRIBUTE_VALUE_KEY, attrValues[j]);
                                logger.trace("We add the add jbutton, attrName:" + attrLabel.getText() + ",value:" + attrValues[j]);
                                addButton.setToolTipText(EditorFieldValue.ADD_VALUE_BUTTON_TOOLTIPTEXT);
                                addButton.setPreferredSize(new Dimension(22, 22)); //22,22
                                addButton.setVisible(false);
                                addButton.addActionListener(new java.awt.event.ActionListener() {

                                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                                        addButtonActionPerformed(evt);
                                    }
                                    });
                                // </editor-fold>

                                // <editor-fold defaultstate="collapsed" desc=" Adds add value button ">
                                gridBagConstraints = new java.awt.GridBagConstraints();
                                gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
                                gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
                                gridBagConstraints.weightx = 0.0;
                                gridBagConstraints.insets = new java.awt.Insets(0, 2, 0, 2);
                                gridBagConstraints.gridx = 2;
                                gridBagConstraints.gridy = row;
                                this.containerPanel.add(addButton, gridBagConstraints);
                                // </editor-fold>

                                // <editor-fold defaultstate="collapsed" desc=" We create the remove value button an sets its properties ">

                                removeButton = new JButton(Utils.createImageIcon(EditorFieldValue.REMOVE_VALUE_BUTTON_IMAGEICON_PATH));
                                removeButton.putClientProperty(EditorFieldValue.ATTRIBUTE_NAME_KEY, attrLabel.getText());
                                removeButton.putClientProperty(EditorFieldValue.ATTRIBUTE_VALUE_KEY, attrValues[j]);
                                logger.trace("We add the remove jbutton, attrName:" + attrLabel.getText() + ",value:" + attrValues[j]);
                                removeButton.setToolTipText(EditorFieldValue.REMOVE_VALUE_BUTTON_TOOLTIPTEXT);
                                removeButton.setPreferredSize(new Dimension(22, 22)); //22,22
                                removeButton.setVisible(false);
                                removeButton.addActionListener(new java.awt.event.ActionListener() {

                                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                                        removeButtonActionPerformed(evt);
                                    }
                                    });
                                // </editor-fold>

                                // <editor-fold defaultstate="collapsed" desc=" Adds remove value button ">
                                gridBagConstraints = new java.awt.GridBagConstraints();
                                gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
                                gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
                                gridBagConstraints.weightx = 0.0;
                                gridBagConstraints.insets = new java.awt.Insets(0, 2, 0, 2);
                                gridBagConstraints.gridx = 3;
                                gridBagConstraints.gridy = row;
                                this.containerPanel.add(removeButton, gridBagConstraints);
                                // </editor-fold>

                                // <editor-fold defaultstate="collapsed" desc=" Creates and adds each attribute-value like an object in a Vector ">
                                if (this.vTextField[i] == null) {
                                    this.vTextField[i] = new Vector();
                                }
                                Object newObject[] = new Object[4];
                                newObject[0] = attrLabel;
                                newObject[1] = valueField;
                                newObject[2] = addButton;
                                newObject[3] = removeButton;
                                this.vTextField[i].addElement(newObject);
                            // </editor-fold>
                            } else {
                                valueField = new JTextField(attrValues[j]);
                                // <editor-fold defaultstate="collapsed" desc=" Adds new value ">
                                gridBagConstraints = new java.awt.GridBagConstraints();
                                gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
                                gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
                                gridBagConstraints.weightx = 1.0;
                                gridBagConstraints.insets = new java.awt.Insets(0, 2, 0, 2);
                                gridBagConstraints.gridx = 1;
                                gridBagConstraints.gridy = row;
                                this.containerPanel.add(valueField, gridBagConstraints);
                                // </editor-fold>

                                // <editor-fold defaultstate="collapsed" desc=" Creates and adds each attribute-value like an object in a Vector ">
                                if (this.vTextField[i] == null) {
                                    this.vTextField[i] = new Vector();
                                }
                                Object newObject[] = new Object[2];
                                newObject[0] = attrLabel;
                                newObject[1] = valueField;
                                this.vTextField[i].addElement(newObject);
                            // </editor-fold>
                            }
                            row++;
                        }
                    }
                }
            }
            //Sets the textfield to disable, to do not allow to edit
            this.setVectorTextFieldEnabled(false);
        }
        // <editor-fold defaultstate="collapsed" desc=" Adds the empty panel ">
        //Add an empty panel
        JPanel panel = new JPanel();
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 2, 0, 2);
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = row;
        this.containerPanel.add(panel, gridBagConstraints);
    // </editor-fold>
    }

    /**Method that is called when the a remove button is clicked
     * 
     * @param evt ActionEvent.
     */
    private void removeButtonActionPerformed(java.awt.event.ActionEvent evt) {
        Object objectEvent = evt.getSource();
        if (objectEvent instanceof JButton) {
            JButton removeButton = (JButton) objectEvent;

            //We get the properties setted to the button: attribute name , and the attribute value
            String attributeName = (String) removeButton.getClientProperty(EditorFieldValue.ATTRIBUTE_NAME_KEY);
            String attributeValue = (String) removeButton.getClientProperty(EditorFieldValue.ATTRIBUTE_VALUE_KEY);

            logger.trace("Remove button action performed, attributeName: " + attributeName + ",attributeValue:" + attributeValue);

            String[] attrValues = this.attributes[LDAPNode.INDEX_ATTRIBUTES].get(attributeName);
            if (attrValues.length > 1) {
                //We remove the value of the attribute name
                HashMap<String, String[]> newHash[] = this.removingAnValue(this.getNewAttributes(), attributeName, attributeValue);
                //We show this panel
                this.setAttributesHashMap(newHash);
                containerPanel.validate();
                containerPanel.repaint();
                setEditableEditor(true);
                this.editorValueMode = EditorFieldValue.EDITOR_MODE_EDIT;
            }
        }
    }

    /**Method that is called when add button is clicked
     * 
     * @param evt ActionEvent.
     */
    private void addButtonActionPerformed(java.awt.event.ActionEvent evt) {
        Object objectEvent = evt.getSource();
        if (objectEvent instanceof JButton) {
            JButton addButton = (JButton) objectEvent;

            //We get the properties setted to the button: attribute name , and the attribute value
            String attributeName = (String) addButton.getClientProperty(EditorFieldValue.ATTRIBUTE_NAME_KEY);
            String attributeValue = (String) addButton.getClientProperty(EditorFieldValue.ATTRIBUTE_VALUE_KEY);

            logger.trace("Add button action performed, attributeName: " + attributeName + ",attributeValue:" + attributeValue);

            HashMap<String, String[]> newHash[] = getCopyOfHasMapAddingValue(getNewAttributes(), attributeName, EditorFieldValue.DEFAULT_ATTRIBUTE_VALUE);
            setAttributesHashMap(newHash);
            editorValueMode = EditorFieldValue.MODE_ADDING_VALUE;
            containerPanel.validate();
            containerPanel.repaint();
            setEditableEditor(true);
        }
    }

    /**Method that sets the textfield of this panel as editable
     * 
     * @param editable boolean. 
     * True - The JTextField will be editable. 
     * False - The JTextField will not be editable.
     */
    private void setVectorTextFieldEnabled(boolean editable) {
        for (int i = 0; i < this.vTextField.length; i++) {
            if (i != LDAPNode.INDEX_OBJECTCLASSES) {
                if (this.vTextField[i] != null) {
                    for (int j = 0; j < this.vTextField[i].size(); j++) {
                        Object[] myObject = (Object[]) this.vTextField[i].elementAt(j);
                        JTextField textField = (JTextField) myObject[1];
                        textField.setEditable(editable);
                    }
                }
            } else {
                if (this.vTextField[i] != null) {
                    for (int j = 0; j < this.vTextField[i].size(); j++) {
                        Object[] myObject = (Object[]) this.vTextField[i].elementAt(j);
                        JTextField textField = (JTextField) myObject[1];
                        textField.setEditable(false);
                    }
                }
            }
        }
    }

    /**Method that returns a copy of the hashmap given as argument adding a new value to the attribute given as argument.
     * 
     * @param oldHash HashMap<String, String[]>[]. This is the original hashmap displayed in the table
     * @param attrNameValueToAdd String. This is the attribute  name that we have to search because we have to add a new value
     * @param valueToAdd String. This is the new value to set to the attribute name
     * @return HashMap<String, String[]>[].
     */
    private HashMap<String, String[]>[] getCopyOfHasMapAddingValue(HashMap<String, String[]> oldHash[], String attributeName, String valueToAdd) {
        HashMap<String, String[]> newHash[] = new HashMap[oldHash.length];
        for (int i = 0; i < oldHash.length; i++) {
            newHash[i] = new HashMap<String, String[]>();
            Iterator it = oldHash[i].entrySet().iterator();
            while (it.hasNext()) {
                Map.Entry entry = (Map.Entry) it.next();
                String attrName = (String) entry.getKey();
                String[] attrValues = (String[]) entry.getValue();
                String[] newAttrValues = null;
                //We have to add a value
                if (i == LDAPNode.INDEX_ATTRIBUTES && attrName.equals(attributeName)) {
                    newAttrValues = new String[attrValues.length + 1];
                    for (int j = 0; j < attrValues.length; j++) {
                        newAttrValues[j] = attrValues[j];
                    }
                    //We set the las value
                    newAttrValues[attrValues.length] = valueToAdd;
                } else {
                    newAttrValues = new String[attrValues.length];
                    for (int j = 0; j < attrValues.length; j++) {
                        newAttrValues[j] = attrValues[j];
                    }
                }
                newHash[i].put(attrName, newAttrValues);
            }
        }
        return newHash;
    }

    /**Method that removes the value of the attribute given as argument
     * 
     * @param oldHash HashMap<String, String[]>[]. This is the original hashmap displayed in the table
     * @param attributeName String. This is the attribute name where we want to remove its value
     * @param valueToRemove String. This is the value which we want to remove
     * @return HashMap<String, String[]>[].
     */
    private HashMap<String, String[]>[] removingAnValue(HashMap<String, String[]> oldHash[], String attributeName, String valueToRemove) {
        HashMap<String, String[]> newHash[] = new HashMap[oldHash.length];
        for (int i = 0; i < newHash.length; i++) {
            newHash[i] = new HashMap<String, String[]>();
            Iterator it = oldHash[i].entrySet().iterator();
            while (it.hasNext()) {
                Map.Entry entry = (Map.Entry) it.next();
                String attrName = (String) entry.getKey();
                String[] attrValues = (String[]) entry.getValue();
                String[] newAttrValues = null;
                //We have to remove the selected value
                if (i == LDAPNode.INDEX_ATTRIBUTES && attrName.equals(attributeName)) {
                    //We create our array values with the correct size
                    newAttrValues = new String[attrValues.length - 1];

                    //We copy al the elements that we want to a vector, we do not copy the element that we do not want
                    Vector<String> myVector = new Vector<String>();
                    for (int j = 0; j < attrValues.length; j++) {
                        if (!attrValues[j].equals(valueToRemove)) {
                            logger.trace("AÃ±adimos myVector[" + j + "]: " + attrValues[j] + ", valor a eliminar: " + valueToRemove);
                            myVector.addElement(attrValues[j]);
                        }
                    }

                    logger.trace("newAttrValues.length:" + newAttrValues.length);

                    //We copy the elements that we had in the vector in our string array newAttrValues
                    for (int j = 0; j < myVector.size(); j++) {
                        newAttrValues[j] = myVector.elementAt(j);
                    }
                } else {
                    newAttrValues = new String[attrValues.length];
                    for (int j = 0; j < attrValues.length; j++) {
                        newAttrValues[j] = attrValues[j];
                    }
                }
                newHash[i].put(attrName, newAttrValues);
            }
        }
        return newHash;
    }

    /**Method that sets this editor to edit
     * 
     * @param editable boolean. This parameter indicates if the editor is setted as editable
     */
    @Override
    public void setEditableEditor(boolean editable) {
        super.setEditableEditor(editable);
        logger.trace("it has been called editable editor");
        this.setVectorTextFieldEnabled(editable);
        this.setMultivaluedAttributesAsEditable(editable);
        containerPanel.validate();
        containerPanel.repaint();
    }

    /**Method that sets the multivalued attributes as editable. 
     * If editable mode = true, then it is shown the add value button and remove value button
     * 
     * @param editable boolean. 
     */
    private void setMultivaluedAttributesAsEditable(boolean editable) {
        Schema schema = ((TreeRootNode) this.ldapNode.getRoot()).getLdapServer().getLdapSchema();

        if (this.vTextField[LDAPNode.INDEX_ATTRIBUTES] != null) {
            for (int i = 0; i < this.vTextField[LDAPNode.INDEX_ATTRIBUTES].size(); i++) {
                Object[] myObject = (Object[]) this.vTextField[LDAPNode.INDEX_ATTRIBUTES].elementAt(i);
                if (myObject.length == 4) {
                    JLabel label = (JLabel) myObject[0];
                    String attributeName = label.getText();
                    if (!schema.isSingleValued(attributeName)) {
                        logger.trace("We have to put as editable: " + editable + " the buttons of " + attributeName);
                        if (myObject[2] != null) {
                            JButton addButton = (JButton) myObject[2];
                            addButton.setVisible(editable);
                        }
                        if (myObject[3] != null && (this.totalValuesForAttributeName(attributeName) > 1)) {
                            JButton removeButton = (JButton) myObject[3];
                            removeButton.setVisible(editable);
                        }
                    }
                }
            }
        }
    }

    /**Method that returns the values number of the attribute name selected
     * 
     * @param attributeName String. This is the attribute name to search its values
     * @return int. This is the number of values contaned by this attribute
     */
    private int totalValuesForAttributeName(String attributeName) {
        int total = 0;
        for (int i = 0; i < this.vTextField[LDAPNode.INDEX_ATTRIBUTES].size(); i++) {
            Object[] myObject = (Object[]) this.vTextField[LDAPNode.INDEX_ATTRIBUTES].elementAt(i);
            if (myObject.length == 4) {
                JLabel label = (JLabel) myObject[0];
                if (attributeName.equals(label.getText())) {
                    logger.trace(attributeName + ", " + label.getText());
                    total++;
                }
            }
        }
        logger.trace("It is returned " + total);
        return total;
    }

    /**Method that gets the values of the attributes updated. 
     * To build this HashMap is used the attribute vTextField[].
     * 
     * @return HashMap String,String[]. This is the hash that contains the attributes and values updated.
     */
    private HashMap<String, String[]>[] getNewAttributes() {
        HashMap<String, String[]>[] myHash = new HashMap[3];
        logger.trace("vTextfield es:" + vTextField);
        logger.trace("vTextfield es:" + vTextField.length);
        for (int i = 0; i < this.vTextField.length; i++) {
            logger.trace("vTextField[" + i + "]:" + vTextField[i]);
            if (vTextField[i] != null) {
                for (int j = 0; j < this.vTextField[i].size(); j++) {
                    if (myHash[i] == null) {
                        myHash[i] = new HashMap<String, String[]>();
                    }
                    Object[] myObject = (Object[]) this.vTextField[i].elementAt(j);
                    JLabel label = (JLabel) myObject[0];
                    JTextField textField = (JTextField) myObject[1];
                    String attrName = label.getText();
                    if (i == LDAPNode.INDEX_OBJECTCLASSES) {
                        attrName = Utils.getAttributeWithoutBold(attrName);
                    }
                    String attrValue = textField.getText();
                    if (myHash[i].containsKey(attrName)) {
                        String[] values = myHash[i].get(attrName);
                        String[] newValues = new String[values.length + 1];
                        //We add to the new array the old values
                        for (int k = 0; k < values.length; k++) {
                            newValues[k] = values[k];
                        }
                        //We add the new value
                        newValues[values.length] = attrValue;
                        myHash[i].remove(attrName);
                        myHash[i].put(attrName, newValues);
                    } else {
                        myHash[i].put(attrName, new String[]{attrValue});
                    }
                }//end for
            } else {  //vTextField = null, this case is when noone attribute was added
                if (myHash[i] == null) {
                    myHash[i] = new HashMap<String, String[]>();
                }
            }
        }
        return myHash;
    }

    /**Method that returns the editor type. This field contains the title of the editor displayed
     * 
     * @return String. This is the title of the editor displayed
     */
    @Override
    public String getEditorType() {
        return DEFAULT_EDITOR_TITLE;
    }

    /**Method that save this changes in the ldap server
     * 
     */
    @Override
    public boolean saveChanges() {
        logger.trace("We set EditableMode = false");
        this.setVectorTextFieldEnabled(false);
        this.newAttributes = this.getNewAttributes();
        logger.trace("Save Changes 1");
        Utils.printHash(this.newAttributes);
        logger.trace("Save Changes 2");
        this.editorValueMode = EditorFieldValue.MODE_EDITING;
        boolean saveOk = super.saveChanges(); //We have to call this method before set the attributes, because it tests the attributes and the changes
        this.setAttributesHashMap(this.attributes);
        containerPanel.validate();
        containerPanel.repaint();
        return saveOk;
    }
}
